{
  "name": "dna",
  "version": "0.1.5",
  "main": "./dna.js",
  "engines": {
    "node": "*"
  },
  "author": {
    "name": "SHIN Suzuki",
    "email": "shinout310@gmail.com"
  },
  "description": "utility functions to handle DNA/RNA string data",
  "keywords": [
    "DNA",
    "RNA",
    "FASTA",
    "sequence",
    "bioinformatics"
  ],
  "readme": "dna\n==========\nUtility functions to handle DNA/RNA strings in bioinformatics. (Node.js)\n\n## Installation ##\n    \n    git clone git://github.com/shinout/dna.git\n\n    OR\n\n    npm install dna\n\n## API Documentation ##\n- dna.complStrand(str, rev, rna)\n- dna.getRandomSeq(len, rna)\n- dna.getFormat(chr, start, end, strand)\n- dna.parseFormat(str, objFormat)\n- dna.writeFasta(rname, seq, wstream, num)\n- dna.padN(seq, len, options)\n- dna.writeFastq(name, seq, qual, wstream)\n- dna.getPosLen(start, end)\n- dna.getStartEnd(pos, len)\n- dna.numberize()\n\n### dna.complStrand(str, rev, rna) ###\nGets a complementary strand of **str**.\n\nIf **rev** is true, reverse the sequence. (5' -> 3').\n\nIf **rna** is true, T -> U .\n\n    dna.complStrand(\"ACCTG\") // TGGAC\n    dna.complStrand(\"ACCTG\", true) // CAGGT\n    dna.complStrand(\"ACCTG\", null, true) // UGGAC\n    dna.complStrand(\"ACCTG\", true, true) // CAGGU\n\n\n### dna.getRandomSeq(len, rna) ###\nGets a random sequence with length **len**.\n\nIf **rna** is true, T -> U.\n\n\n### dna.getFormat(chr, start, end, strand) ###\nGets a formatted position expression by four information.\n\nHere is the formatted position expression.\n\n    chr13:12345678-13456789,-\n    <reference name>:<0 based start>-<0 based end>,<strand>\n\nSo this function returns\n\n**chr**:**start**-**end**,**strand**\n\n\n### dna.parseFormat(str, objFormat) ###\nParses **str** as a formatted position expression.\n\nif **objFormat** is true, returns \n\n    { chr    : \"chr13\",\n      start  : 12345678,\n      end    : 13456789,\n      strand : '-'\n    }\n\nBy default, returns an array.\n\n    [\"chr13\", 12345678, 13456789, '-']\n\n### dna.writeFasta(rname, seq, wstream, num) ###\nWrites fasta to **wstream**.\n\n**rname** is the reference name. Required.\n\n**seq** is the sequence to write. Required.\n\n**wstream** is a writable stream. By default, process.stdout.\n\n**num** is number to fold. By default, 50.\n\nReturns nothing.\n\n    dna.writeFasta(\"title\", \"GCTTCAA\");\n    // >title\n    // GCTTCAA\n\n### dna.padN(seq, len, options) ###\nPads N till the **seq**.length becomes **len**.\n\n**seq** is a string.\n**len** is a number.\n\n**options** is optional object.\n\nIf **options.cutIfOver** is true, and **seq**.length > **len** already, cuts the **seq**.\n\nIf **options.left** is true, pads Ns to the right of **seq**. (N are padded at the right by default.)\n\n\n    dna.padN(\"ACGA\", 10) // ACGANNNNNN\n    dna.padN(\"ACGA\", 3)  // ACGA\n    dna.padN(\"ACGA\", 3, {cutIfOver: true})  // ACG\n    dna.padN(\"ACGA\", 10, {left: true}) // NNNNNNACGA\n\n\n### dna.writeFastq(name, seq, qual, wstream) ###\nWrites fastq to **wstream**.\n\n**name** is the name of the sequence. Required.\n\n**seq** is the sequence to write. Required.\n\n**qual** is the base quality of the sequence. **qual**.length === ***seq***.length.\n\n**wstream** is a writable stream. By default, process.stdout.\n\nReturns nothing.\n\n    dna.writeFastq(\"title\", \"GCTTCAA\", \"IIHHHAI\");\n    // @title\n    // GCTTCAA\n    // +\n    // IIHHHAI\n\n\n### dna.getPosLen(start, end) ###\nReturns 1-based coordinate position and the length from 0-based coordinate start and end.\n\nReturns an array.\n\nReturns [**start**+1, **end**-**start**]\n\n    dna.getPosLen(3, 10) // [4, 7]\n\n\n### dna.getStartEnd(pos, len) ###\nReturns 0-based coordinate start and end from 1-based coordinate position and the length.\n\nReturns an array.\n\nReturns [**pos**-1, **pos** + **len** -1]\n\n    dna.getStartEnd(3, 10) // [2, 12]\n\n\n### dna.numberize(num, _default) ###\n### dna.numberize(num, name) ###\n\nNumberize **num**.\n\nIf Number(num) is NaN, returns **_default** if given. Otherwise throw an error.\n**name** is used to specify which number occurs the error.\n\n    dna.numberize(\"14\") // 14\n    dna.numberize(\"AA\", 10) // 10\n    dna.numberize(\"AA\", \"position\") // throws an error: \"position is NaN\"\n\n\n## unstable APIs ##\n### dna.getChromCode(name, nothrow) ###\nGets the code (id) of a given chromosome\n\n- chr9  -> 9\n- chr22 -> 22\n- chrX  -> 23\n- chrY  -> 24\n- chrM  -> 25\n- others: -> an exception is thrown.\n\n**name** is the name of a chromosome.\n\nIf **nothrow** is true and not found, returns the original value.\n\n\n### dna.getRegularName(name) ###\nGets the canonical names of a given chromosome.\n\n- 9  -> chr9\n- chromosome22 -> chr22\n- CHRUN_GN000239 -> chrUn_gl000239\n- others: -> throw exception\n\n**name** is the name of a chromosome\n\n\n### dna.getChromList(code, fn) ###\nGets possible reference names from the code\n\n- 9  -> [9, chr9, Chr9, CHR9, chrom9, Chrom9, CHROM9]\n\n**code** is a chromosome code or chromosome name\n\n**fn** is optional.\nFunction with its arguments each rname candidate.\nReturns some value when rname is valid,\nReturns false when invalid.\nIf this argument is set, **dna.getChromList()** returns the value **fn** returns.\n\n",
  "_id": "dna@0.1.5",
  "_from": "dna@>=0.1.5"
}
